/*
 * ReferenceMatcher.java
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.apple.foundationdb.record.query.plan.temp.matchers;

import com.apple.foundationdb.annotation.API;
import com.apple.foundationdb.record.query.plan.temp.Bindable;
import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;
import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;
import com.apple.foundationdb.record.query.plan.temp.matchers.ExpressionMatcher.DefaultMatcher;

import javax.annotation.Nonnull;
import java.util.List;
import java.util.stream.Stream;

/**
 * An expression matcher that matches against any reference at all. It is frequently used by rules that want to capture
 * everything behind a reference without regard for its content. The bindings generated by a {@code ReferenceMatcher}
 * do not provide any access to what was matched. However, the references from the binding can be used when constructing
 * new planner expressions to yield to the planner, which is especially efficient when the references are groups.
 *
 * Although the {@code ReferenceMatcher} has a type parameter, it cannot statically verify that the type of {@link RelationalExpression}
 * behind a reference actually matches its type parameter, because of type erasure. It is up to the programmer to verify
 * that the type parameter is general enough to cover every possible type of {@code PlannerExpression} that might be behind
 * any reference that it could be matched to. In general, the programmer will be certain that a reference would contain
 * a particular type because an expression of a certain type is always found in a particular position of the iterator
 * returned by {@link RelationalExpression#getQuantifiers()}. For example, it would be safe to use a
 * {@code ReferenceMatcher<QueryComponent>} to match against the second planner expression child of a
 * {@link com.apple.foundationdb.record.query.plan.plans.RecordQueryFilterPlan} because that child is necessarily a
 * {@code QueryComponent}; note that there is no way for the type system to know that, so the programmer must track
 * such information when writing rules. If the wrong type is used for the type parameter, the {@link PlannerBindings}
 * will throw a {@link ClassCastException}.
 */
@API(API.Status.EXPERIMENTAL)
public abstract class ReferenceMatcher extends DefaultMatcher<ExpressionRef<? extends RelationalExpression>> implements ExpressionMatcher<ExpressionRef<? extends RelationalExpression>> {
    public ReferenceMatcher() {
    }

    @Nonnull
    @Override
    public Class<? extends Bindable> getRootClass() {
        return ExpressionRef.class;
    }

    /**
     * Return a new {@code ReferenceMatcher} instance. The returned matcher is guaranteed to be distinct (according to
     * pointer comparison) from the matchers returned by other calls to {@code anyRef()}, so that multiple such matchers
     * may be used in a single {@link PlannerBindings} object.
     * @return a new, distinct matcher that matches to any reference
     */
    public static ReferenceMatcher anyRef() {
        return new ReferenceMatcher() {
            @Nonnull
            @Override
            public Stream<PlannerBindings> matchWith(@Nonnull final PlannerBindings outerBindings, @Nonnull final ExpressionRef<? extends RelationalExpression> ref,
                                                     @Nonnull final List<? extends Bindable> children) {
                return Stream.of(PlannerBindings.from(this, ref));
            }
        };
    }

    /**
     * Return a new {@code ReferenceMatcher} instance. The returned matcher is guaranteed to be distinct (according to
     * pointer comparison) from the matchers returned by other calls to {@code anyRef()}, so that multiple such matchers
     * may be used in a single {@link PlannerBindings} object.
     * @param membersMatcher a matcher that is applied to the members of this reference
     * @return a new, distinct matcher that matches to the cross product of references and their respective members matching
     *         the {@code membersMatcher}.
     */
    public static ReferenceMatcher of(@Nonnull ExpressionMatcher<? extends Bindable> membersMatcher) {
        final AnyChildMatcher childrenMatcher = AnyChildMatcher.anyMatching(membersMatcher);
        return new ReferenceMatcher() {
            @Nonnull
            @Override
            public Stream<PlannerBindings> matchWith(@Nonnull final PlannerBindings outerBindings, @Nonnull final ExpressionRef<? extends RelationalExpression> ref,
                                                     @Nonnull final List<? extends Bindable> children) {
                return Stream.of(PlannerBindings.from(this, ref))
                        .flatMap(bindings -> childrenMatcher.matches(outerBindings, children)
                                .map(bindings::mergedWith));
            }
        };
    }
}

