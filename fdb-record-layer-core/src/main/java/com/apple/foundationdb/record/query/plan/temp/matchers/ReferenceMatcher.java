/*
 * ReferenceMatcher.java
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.apple.foundationdb.record.query.plan.temp.matchers;

import com.apple.foundationdb.annotation.API;
import com.apple.foundationdb.record.query.plan.temp.Bindable;
import com.apple.foundationdb.record.query.plan.temp.ExpressionRef;
import com.apple.foundationdb.record.query.plan.temp.Quantifier;
import com.apple.foundationdb.record.query.plan.temp.RelationalExpression;
import com.apple.foundationdb.record.query.predicates.QueryPredicate;

import javax.annotation.Nonnull;
import java.util.List;
import java.util.stream.Stream;

/**
 * An expression matcher that matches against any reference at all. It is frequently used by rules that want to capture
 * everything behind a reference without regard for its content. The bindings generated by a {@code ReferenceMatcher}
 * do not provide any access to what was matched. However, the references from the binding can be used when constructing
 * new planner expressions to yield to the planner, which is especially efficient when the references are groups.
 *
 * Although the {@code ReferenceMatcher} has a type parameter, it cannot statically verify that the type of {@link RelationalExpression}
 * behind a reference actually matches its type parameter, because of type erasure. It is up to the programmer to verify
 * that the type parameter is general enough to cover every possible type of {@code PlannerExpression} that might be behind
 * any reference that it could be matched to. In general, the programmer will be certain that a reference would contain
 * a particular type because an expression of a certain type is always found in a particular position of the iterator
 * returned by {@link RelationalExpression#getQuantifiers()}. For example, it would be safe to use a
 * {@code ReferenceMatcher<QueryComponent>} to match against the second planner expression child of a
 * {@link com.apple.foundationdb.record.query.plan.plans.RecordQueryFilterPlan} because that child is necessarily a
 * {@code QueryComponent}; note that there is no way for the type system to know that, so the programmer must track
 * such information when writing rules. If the wrong type is used for the type parameter, the {@link PlannerBindings}
 * will throw a {@link ClassCastException}.
 * @param <T> the type of planner expression that this matcher will always bind to
 */
@API(API.Status.EXPERIMENTAL)
public class ReferenceMatcher<T extends RelationalExpression> implements ExpressionMatcher<ExpressionRef<T>> {
    @Nonnull
    private final ExpressionChildrenMatcher childrenMatcher;

    public ReferenceMatcher(@Nonnull final ExpressionChildrenMatcher childrenMatcher) {
        this.childrenMatcher = childrenMatcher;
    }

    @Nonnull
    @Override
    public Class<? extends Bindable> getRootClass() {
        return RelationalExpression.class;
    }

    @Nonnull
    @Override
    public ExpressionChildrenMatcher getChildrenMatcher() {
        return childrenMatcher;
    }

    @Nonnull
    @Override
    public Stream<PlannerBindings> matchWith(@Nonnull final ExpressionRef<? extends RelationalExpression> ref,
                                             @Nonnull List<? extends Bindable> children) {
        return Stream.of(PlannerBindings.from(this, ref))
                .flatMap(outerBindings -> getChildrenMatcher().matches(children)
                        .map(outerBindings::mergedWith));
    }

    @Nonnull
    @Override
    public Stream<PlannerBindings> matchWith(@Nonnull RelationalExpression expression, @Nonnull final List<? extends Bindable> children) {
        return Stream.empty();
    }

    @Nonnull
    @Override
    public Stream<PlannerBindings> matchWith(@Nonnull QueryPredicate predicate, @Nonnull final List<? extends Bindable> children) {
        return Stream.empty();
    }

    @Nonnull
    @Override
    public Stream<PlannerBindings> matchWith(@Nonnull final Quantifier quantifier, @Nonnull final List<? extends Bindable> children) {
        return Stream.empty();
    }

    /**
     * Return a new {@code ReferenceMatcher} instance. The returned matcher is guaranteed to be distinct (according to
     * pointer comparison) from the matchers returned by other calls to {@code anyRef()}, so that multiple such matchers
     * may be used in a single {@link PlannerBindings} object.
     * @param <U> the type of {@link RelationalExpression} that is guaranteed (by programmer knowledge) to be behind the references that this matcher will bind to
     * @return a new, distinct matcher that matches to any reference
     */
    public static <U extends RelationalExpression> ReferenceMatcher<U> anyRef() {
        // This must return a new matcher so that it is distinct from other ReferenceMatchers according to pointer comparison.
        return new ReferenceMatcher<>(AnyChildrenMatcher.ANY);
    }

    /**
     * Return a new {@code ReferenceMatcher} instance. The returned matcher is guaranteed to be distinct (according to
     * pointer comparison) from the matchers returned by other calls to {@code anyRef()}, so that multiple such matchers
     * may be used in a single {@link PlannerBindings} object.
     * @param <U> the type of {@link RelationalExpression} that is guaranteed (by programmer knowledge) to be behind the references that this matcher will bind to
     * @param membersMatcher a matcher that is applied to the members of this reference
     * @return a new, distinct matcher that matches to the cross product of references and their respective members matching
     *         the {@code membersMatcher}.
     */
    public static <U extends RelationalExpression> ReferenceMatcher<U> of(@Nonnull ExpressionMatcher<? extends Bindable> membersMatcher) {
        // This must return a new matcher so that it is distinct from other ReferenceMatchers according to pointer comparison.
        return new ReferenceMatcher<>(AnyChildMatcher.anyMatching(membersMatcher));
    }
}

