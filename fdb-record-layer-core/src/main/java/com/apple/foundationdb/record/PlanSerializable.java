/*
 * PlanSerializable.java
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2015-2018 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.apple.foundationdb.record;

import com.apple.foundationdb.annotation.API;
import com.google.protobuf.Message;

import javax.annotation.Nonnull;

/**
 * Base interface to indicate that a java class is reachable through a
 * {@link com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan} and therefore needs to be capable of
 * serialization/deserialization. In addition to the {@link #toProto(PlanSerializationContext)} defined here
 * each implementor also needs to provide a {@code public static fromProto(PlanSerializationContext, PClass)}
 * method that we can dynamically dispatch to when deserializing a proto message.
 * <br>
 * Plan serialization and naturally the inverse, plan deserialization, is done using precompiled protobuf. There is some
 * boilerplate that is necessary to be aware of when extending existing plan structures or adding new plan operators
 * themselves.
 * <br>
 * All classes that are serializable for plan serialization purposed must implement {@link PlanSerializable}.
 * That interface complements {@link PlanHashable} which is doing similar things to compute a deterministic and stable
 * hash code for a plan. Each class {@code SomeClass} implementing {@link PlanSerializable} has a counterpart protobuf
 * message called {@code PSomeClass}. This convention was chosen in order to allow both classes to be referenced with
 * just regular imports within the same java class.
 * <br>
 * {@link PlanSerializable} defines a method {@code Message toProto(PlanSerializationContext)} that implementors must
 * provide. Note that this method should be covariant if possible. There are situations where thatâ€™s not possible in
 * which case we revert to a less elegant approach. In any case, the serialization framework will only interpret the
 * result as a proto Message. This method is used to transform from SomeClass to PSomeClass.
 * <br>
 * The inverse method called {@code fromProto(...)} requires a little more magic. One would naturally add that method
 * to {@code PSomeClass} which is unfortunately not possible as {@code PSomeClass} is generated by the protobuf
 * compiler. We instead add {@code fromProto(...)} as a public static factory method to {@code SomeClass} instead.
 * The full signature of this method is
 * <pre>
 * <code>
 * {@literal @}Nonnull
 * public static SomeClass fromProto(PlanSerializationContext sC,
 *                                   PSomeClass someClassProto);
 * </code>
 * </pre>
 * <br>
 * Every class implementing {@link PlanSerializable} is expected to implement this method as well.
 * <br>
 * Now that we have a {@code toProto(...)} and a {@code fromProto(...)}, not everything is sorted out yet. Again, we are
 * in control of {@code toProto(...)} which also happens to be implemented within the record layer class structure.
 * Therefore, we can easily instantiate the correct proto class and populate its fields. However, the opposite is not
 * true. If we were to call a {@code fromProto()} method directly we may know the exact record layer class and could
 * potentially instantiate that class, however, a lot of record layer classes implement a common interface
 * (e.g. {@link com.apple.foundationdb.record.query.plan.plans.RecordQueryPlan}) and then refer to any kind of specific
 * plan just by using a reference to the interface or a superclass. We have to build that substitution principle
 * (we can substitute a reference to a super class or interface with a subclass respectively implementing class)
 * into the serialization framework.
 * <br>
 * The example we use here is for the record layer interface
 * {@link com.apple.foundationdb.record.query.plan.cascades.values.Value} which has dozens of implementors. Value
 * itself extends quite a few interfaces of its own.
 * {@link com.apple.foundationdb.record.query.plan.cascades.values.Value} has a protobuf correspondent called
 * {@code PValue} which is defined as follows (incomplete):
 * <pre>
 * {@code
 * message PValue {
 *   extensions 5000 to max;
 *
 *   oneof specific_value {
 *     PLightArrayConstructorValue light_array_constructor_value = 1;
 *     PAndOrValue and_or_value = 2;
 *     PArithmeticValue arithmetic_value = 3;
 *     PConditionSelectorValue condition_selector_value = 4;
 *     PConstantObjectValue constant_object_value = 5;
 *     PConstantValue constant_value = 6;
 *     PCountValue count_value = 7;
 *     ...
 *     PBinaryRelOpValue binary_rel_op_value = 34;
 *     PUnaryRelOpValue unary_rel_op_value = 35;
 *     PVariadicFunctionValue variadic_function_value = 36;
 *     PVersionValue version_value = 37;
 *   }
 * }
 * }
 * </pre>
 *
 * PValue is a protobuf message that only ever holds exactly one actual implementing P-message. We could now provide
 * a {@code fromProto(...)} in Value to create the correct object of the right implementing class. That, however, is
 * just boilerplate and quite tedious to maintain. We are effectively doing the dynamic dispatch we get for free on
 * the {@code toProto(...)} path by hand. If there is no help at this point we were forced to write this code:
 * <br>
 * <pre>
 * {@code
 * if (proto.hasLightArrayConstructorValue()) {
 *     return LightArrayConstructorValue.fromProto(sC, proto.getLightArrayConstructorValue());
 * } else if (proto.hasAndOrValue()) {
 *     return AndOrValue.fromProto(sC, proto.getAndOrValue());
 * } else if (proto.hasArithmeticValue()) {
 *     return ArithmeticValue.fromProto(sC, proto.getArithmeticValue());
 * } else if (...) {
 *     ...
 * } else {
 *     throw new RecordCoreException("you mad?");
 * }
 * }
 * </pre>
 * This sort of logic is hard to maintain over time. Instead, we use an auto-service pattern on the interface
 * {@link PlanDeserializer} that must also be implemented by every specific implementor of {@code Value} that relates
 * proto-class and java class (in the example {@code PLightArrayConstructorValue} and
 * {@code LightArrayConstructorValue}:
 * <br>
 * <pre>
 * <code>
 *   {@literal @}AutoService(PlanDeserializer.class)
 *   public static class Deserializer implements PlanDeserializer{@literal <}PLightArrayConstructorValue, LightArrayConstructorValue{@literal >} {
 *       {@literal @}@Nonnull
 *       {@literal @}Override
 *       public Class{@literal <}PLightArrayConstructorValue{@literal >} getProtoMessageClass() {
 *           return PLightArrayConstructorValue.class;
 *       }
 *
 *       {@literal @}Nonnull
 *       {@literal @}Override
 *       public LightArrayConstructorValue fromProto(final PlanSerializationContext serializationContext,
 *                                                   final PLightArrayConstructorValue lightArrayConstructorValueProto) {
 *           return LightArrayConstructorValue.fromProto(serializationContext, lightArrayConstructorValueProto);
 *       }
 *   }
 * </code>
 * </pre>
 */
@API(API.Status.UNSTABLE)
public interface PlanSerializable {
    @Nonnull
    Message toProto(@Nonnull PlanSerializationContext serializationContext);
}
