/*
 * Element.java
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2015-2019 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.apple.foundationdb.record.query.plan.temp.view;

import com.apple.foundationdb.annotation.API;
import com.apple.foundationdb.record.PlanHashable;
import com.apple.foundationdb.record.query.plan.temp.ComparisonRange;
import com.apple.foundationdb.record.query.plan.temp.Correlated;
import com.apple.foundationdb.record.query.predicates.ElementPredicate;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.Optional;
import java.util.Set;

/**
 * A value in the {@link ViewExpression} language that can be represented as an element of FoundationDB tuple.
 *
 * <p>
 * An element is the atom of a FoundationDB tuple, and therefore has a representation as a byte string with a defined
 * total order (i.e., an order where {@code a <= b} and {@code b <= a} implies that {@code a == b}, and where either
 * {@code a <= b} or {@code b <= a}). Elements generate the values that can be used to define the projection, predicate,
 * sort order, or grouping of a view expression. Since elements must be usable in FoundationDB tuples, they are also
 * the fundamental unit of key planning operations such as incremental index selection. Many, but not all, elements
 * reference a {@link Source} which identifies what streams of data will generate them.
 * </p>
 */
@API(API.Status.EXPERIMENTAL)
public interface Element extends PlanHashable, Correlated<Element> {
    /**
     * Determine whether this element can be used to satisfy the given {@link ElementPredicate}, under the assumption
     * that this element is already being used to satisfy the given {@link ComparisonRange}. Note that this method
     * relies on strict comparisons between elements, i.e., the sources must be reference-equal to each other.
     * @param existingComparisons a range of existing comparisons that the planner is using this element to support
     * @param predicate an element predicate to match with this element and the given comparison range
     * @return a new comparison range incorporating the predicate's comparison if the match was successful, {@code Optional.empty()} otherwise
     */
    @Nonnull
    Optional<ComparisonRange> matchWith(@Nonnull ComparisonRange existingComparisons, @Nonnull ElementPredicate predicate);

    /**
     * Determine whether this element is the same as the given {@link Element} when unused sources are combined with
     * each other. Sources are determined to be used or unused based on their usage in the given
     * {@link ViewExpressionComparisons}. A source is used if any element using that source has a comparison already
     * matched to it; otherwise, it is unused. If an available match is found, produce a version of the given
     * {@code ViewExpressionComparisons} with all instances of this element's source replaced with the given element's
     * source.
     *
     * <p>
     * This method makes it possible to match {@link ElementPredicate}s generated by normalizing a
     * {@link com.apple.foundationdb.record.query.expressions.QueryComponent} with those generated by normalizing a
     * {@link com.apple.foundationdb.record.metadata.expressions.KeyExpression}. These normalization processes are
     * decoupled so the sources for each will not match in general; therefore, {@link #matchWith(ComparisonRange, ElementPredicate)}
     * will fail to notice when an index defined by a {@link com.apple.foundationdb.record.metadata.expressions.KeyExpression}
     * can support a predicate.
     * </p>
     *
     * @param viewExpressionComparisons view expression comparisons that determine which sources are used and unused
     * @param element an element to compare with this one and look for matches made through combining sources
     * @return a new view expression comparisons with instances of this element's source replaced with the given element's
     *         if a match is found, {@code Optional.empty()} otherwise
     */
    @Nonnull
    Optional<ViewExpressionComparisons> matchSourcesWith(@Nonnull ViewExpressionComparisons viewExpressionComparisons,
                                                         @Nonnull Element element);

    /**
     * Get the set of all sources for this element, including all ancestors of this element's sources.
     * @return a set of the sources of all (inclusive) ancestors of this element's sources
     */
    @Nonnull
    Set<Source> getAncestralSources();

    /**
     * Replace the given duplicate source with the given original source everywhere that it occurs in this element,
     * including in ancestor sources of this element's source.
     * @param originalSource a source to replace all occurrences of the duplicate source with
     * @param duplicateSource a source to replace with the original source
     * @return a copy of this element with all occurrences of the duplicate source replaced with the original source
     */
    @Nonnull
    Element withSourceMappedInto(@Nonnull Source originalSource, @Nonnull Source duplicateSource);

    /**
     * Evaluate this element with respect to the given source entry, producing an object that can be interpreted
     * by a {@link com.apple.foundationdb.record.query.expressions.Comparisons.Comparison}.
     * @param sourceEntry a source entry to use when evaluating this element
     * @return the value of this element on the given source entry
     */
    @Nullable
    Object eval(@Nonnull SourceEntry sourceEntry);
}
