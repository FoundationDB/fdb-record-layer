/*
 * AbstractValueRuleCall.java
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2015-2022 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.apple.foundationdb.record.query.plan.cascades.values.simplification;

import com.apple.foundationdb.annotation.API;
import com.apple.foundationdb.record.EvaluationContext;
import com.apple.foundationdb.record.query.plan.QueryPlanConstraint;
import com.apple.foundationdb.record.query.plan.cascades.AliasMap;
import com.apple.foundationdb.record.query.plan.cascades.CorrelationIdentifier;
import com.apple.foundationdb.record.query.plan.cascades.LinkedIdentitySet;
import com.apple.foundationdb.record.query.plan.cascades.PlannerRule;
import com.apple.foundationdb.record.query.plan.cascades.PlannerRuleCall;
import com.apple.foundationdb.record.query.plan.cascades.matching.structure.PlannerBindings;
import com.apple.foundationdb.record.query.plan.cascades.values.Value;
import com.google.common.base.Verify;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Streams;

import javax.annotation.Nonnull;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.function.Function;

/**
 * A rule call implementation for the simplification of {@link Value} trees. This rule call implements the logic for
 * handling new {@link Value}s as they are generated by a {@link AbstractValueRule#onMatch(PlannerRuleCall)} and
 * passed to the rule call via the {@link #yieldResult(Object)} method.
 * <p>
 * The rule call implementation is responsible for registering any new expressions generated by the rule
 * via the {@link #yieldResult(Object)} method. This registration process includes updating any planner data
 * structures to include the new expression. In general, each planner will have an associated implementation of
 * <code>PlannerRuleCall</code>.
 * </p>
 * @param <RESULT> the type parameter representing the type of result that is handed to {@link #yieldResult(Object)}
 * @param <CALL> the type of this
 * @param <BASE> the type of entity the associated rule matches`
 *
 */
@API(API.Status.EXPERIMENTAL)
public class AbstractRuleCall<RESULT, CALL extends AbstractRuleCall<RESULT, CALL, BASE>, BASE> implements PlannerRuleCall {
    @Nonnull
    private final PlannerRule<CALL, ? extends BASE> rule;
    @Nonnull
    private final BASE root;
    @Nonnull
    private final BASE current;
    @Nonnull
    private final EvaluationContext evaluationContext;
    @Nonnull
    private final PlannerBindings bindings;
    @Nonnull
    private final AliasMap equivalenceMap;
    @Nonnull
    private final Set<CorrelationIdentifier> constantAliases;
    @Nonnull
    private QueryPlanConstraint resultQueryPlanConstraint;
    @Nonnull
    private final LinkedIdentitySet<RESULT> results;
    private boolean shouldReExplore;
    @Nonnull
    private final Function<BASE, QueryPlanConstraint> retrieveQueryPlanConstraintFunction;

    public AbstractRuleCall(@Nonnull final PlannerRule<CALL, ? extends BASE> rule,
                            @Nonnull final BASE root,
                            @Nonnull final BASE current,
                            @Nonnull final EvaluationContext evaluationContext,
                            @Nonnull final PlannerBindings bindings,
                            @Nonnull final AliasMap equivalenceMap,
                            @Nonnull final Set<CorrelationIdentifier> constantAliases,
                            @Nonnull final Function<BASE, QueryPlanConstraint> retrieveQueryPlanConstraintFunction) {
        this.rule = rule;
        this.root = root;
        this.current = current;
        this.evaluationContext = evaluationContext;
        this.bindings = bindings;
        this.equivalenceMap = equivalenceMap;
        this.resultQueryPlanConstraint = QueryPlanConstraint.noConstraint();
        this.results = new LinkedIdentitySet<>();
        this.constantAliases = ImmutableSet.copyOf(constantAliases);
        this.shouldReExplore = false;
        this.retrieveQueryPlanConstraintFunction = retrieveQueryPlanConstraintFunction;
    }

    @Nonnull
    public BASE getRoot() {
        return root;
    }

    @Nonnull
    public BASE getCurrent() {
        return current;
    }

    @Nonnull
    @Override
    public EvaluationContext getEvaluationContext() {
        return evaluationContext;
    }

    @Nonnull
    protected Function<BASE, QueryPlanConstraint> getRetrieveQueryPlanConstraintFunction() {
        return retrieveQueryPlanConstraintFunction;
    }

    @Nonnull
    public QueryPlanConstraint getQueryPlanConstraint(@Nonnull final BASE base) {
        final var constraintFromFunction = retrieveQueryPlanConstraintFunction.apply(base);
        return constraintFromFunction == null ? QueryPlanConstraint.noConstraint() : constraintFromFunction;
    }

    @SuppressWarnings("PMD.CompareObjectsWithEquals")
    public boolean isRoot() {
        return root == current;
    }

    @Nonnull
    public PlannerRule<CALL, ? extends BASE> getRule() {
        return rule;
    }

    @Override
    @Nonnull
    public PlannerBindings getBindings() {
        return bindings;
    }

    @Nonnull
    public AliasMap getEquivalenceMap() {
        return equivalenceMap;
    }

    @Nonnull
    public Set<CorrelationIdentifier> getConstantAliases() {
        return constantAliases;
    }

    public void yieldResult(@Nonnull final RESULT value) {
        yieldResult(value, QueryPlanConstraint.noConstraint());
    }

    @SuppressWarnings("PMD.CompareObjectsWithEquals") // deliberate use of == equality check for short-circuit condition
    public void yieldResult(@Nonnull final RESULT value,
                            @Nonnull final QueryPlanConstraint additionalQueryPlanConstraint) {
        if (value == current) {
            return;
        }
        composeAdditionalConstraint(additionalQueryPlanConstraint);
        results.add(value);
    }

    protected void composeAdditionalConstraint(final @Nonnull QueryPlanConstraint additionalQueryPlanConstraint) {
        if (resultQueryPlanConstraint.isConstrained()) {
            this.resultQueryPlanConstraint = resultQueryPlanConstraint.compose(additionalQueryPlanConstraint);
        }
    }

    public void yieldResultAndReExplore(@Nonnull final RESULT value) {
        yieldResultAndReExplore(value, QueryPlanConstraint.noConstraint());
    }


    @SuppressWarnings("PMD.CompareObjectsWithEquals")
    public void yieldResultAndReExplore(@Nonnull RESULT value,
                                        @Nonnull final QueryPlanConstraint additionalQueryPlanConstraint) {
        Verify.verify(value != current);
        composeAdditionalConstraint(additionalQueryPlanConstraint);
        results.add(value);
        shouldReExplore = true;
    }

    @Nonnull
    public QueryPlanConstraint getResultQueryPlanConstraint() {
        return resultQueryPlanConstraint;
    }

    @Nonnull
    public Collection<RESULT> getResults() {
        return Collections.unmodifiableCollection(results);
    }

    public boolean shouldReExplore() {
        return shouldReExplore;
    }

    @Nonnull
    public YieldResultBuilder yieldResultBuilder() {
        return new YieldResultBuilder();
    }

    public final class YieldResultBuilder {
        @Nonnull
        private final List<BASE> bases;

        public YieldResultBuilder() {
            this.bases = Lists.newArrayList();
        }

        @SuppressWarnings({"UseBulkOperation", "ManualArrayToCollectionCopy"}) // due to varargs warning when using bulk operations
        @SafeVarargs
        public final YieldResultBuilder addConstraintsFrom(@Nonnull final BASE... additionalBases) {
            for (final var additionalBase : additionalBases) {
                bases.add(additionalBase);
            }
            return this;
        }

        public YieldResultBuilder addConstraintsFrom(@Nonnull Iterable<? extends BASE> additionalBases) {
            Streams.stream(additionalBases).forEach(bases::add);
            return this;
        }

        public void yieldResult(@Nonnull final RESULT value) {
            AbstractRuleCall.this.yieldResult(value, computeConstraintFromBases());
        }

        public void yieldResultAndReExplore(@Nonnull final RESULT value) {
            AbstractRuleCall.this.yieldResultAndReExplore(value, computeConstraintFromBases());
        }

        @Nonnull
        private QueryPlanConstraint computeConstraintFromBases() {
            return bases.stream()
                    .map(AbstractRuleCall.this::getQueryPlanConstraint)
                    .reduce(QueryPlanConstraint::compose)
                    .orElse(QueryPlanConstraint.noConstraint());
        }
    }
}
