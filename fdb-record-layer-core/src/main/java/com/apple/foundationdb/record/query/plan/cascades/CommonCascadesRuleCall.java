/*
 * CommonCascadesRuleCall.java
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2015-2025 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.apple.foundationdb.record.query.plan.cascades;

import com.apple.foundationdb.record.query.plan.cascades.debug.Debugger;

import javax.annotation.Nonnull;
import java.util.Optional;

/**
 * Interface to capture all methods that both exploration and implementation rules are always allowed to call.
 */
public interface CommonCascadesRuleCall {
    /**
     * Returns the current {@link PlannerPhase}.
     * @return the current {@link PlannerPhase}
     */
    @Nonnull
    PlannerPhase getPlannerPhase();

    /**
     * Returns the root {@link Reference} of the expression DAG.
     * @return the root {@link Reference} of the expression DAG
     */
    @Nonnull
    Reference getRoot();

    /**
     * Returns a newly constructed alias resolver based upon the current memoization structures. This allows callers
     * to find referencing expressions of expressions, etc.
     * @return a newly constructed alias resolver
     */
    @Nonnull
    Quantifiers.AliasResolver newAliasResolver();

    /**
     * Get the planning context with metadata that might be relevant to the planner, such as the list of available
     * match candidates.
     *
     * @return a {@link PlanContext} object with various metadata that could affect planning
     */
    @Nonnull
    PlanContext getContext();

    /**
     * Returns the value for a given planner constraint if it exists.
     * @param plannerConstraint the planner constraint
     * @param <T> the type of the constraint value
     * @return {@code Optional.of(...)} the current value for the requested constraint if it exists, otherwise
     *         {@code Optional.empty()}
     */
    @Nonnull
    <T> Optional<T> getPlannerConstraintMaybe(@Nonnull PlannerConstraint<T> plannerConstraint);

    /**
     * Push a constraint to the {@link Reference} passed in.
     * @param reference the reference this constraint should be pushed to
     * @param plannerConstraint the constraint to push
     * @param constraintValue the constraint value
     * @param <T> the type parameter of {@code constraintValue}
     */
    <T> void pushConstraint(@Nonnull Reference reference,
                            @Nonnull PlannerConstraint<T> plannerConstraint,
                            @Nonnull T constraintValue);

    /**
     * Emit a planner event to the debugger. That event can then be used to set break points or for statistical
     * analysis. Normally, planner events are generated by implementations of
     * {@link com.apple.foundationdb.record.query.plan.cascades.CascadesPlanner.Task} directly. However, it is useful
     * to define additional locations for specific bookkeeping. The event being emitted is only counted, that is
     * no timing information is derived and made available. Note that the caller should never emit events using
     * {@link com.apple.foundationdb.record.query.plan.cascades.debug.Debugger.Location#BEGIN} and
     * {@link com.apple.foundationdb.record.query.plan.cascades.debug.Debugger.Location#END}.
     * @param location the location to be used for the event to be emitted.
     */
    void emitEvent(@Nonnull Debugger.Location location);
}
