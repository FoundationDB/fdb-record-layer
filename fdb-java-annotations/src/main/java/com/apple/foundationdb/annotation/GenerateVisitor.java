/*
 * GenerateVisitor.java
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2015-2020 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.apple.foundationdb.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation to cause the annotation processor {@link GenerateVisitorAnnotationProcessor} to create a visitor for all
 * implementors of an interface or all subclasses of a root class that can be discovered in the current compilation unit.
 *
 * The generated visitor interface contains an overloaded visit method per discovered implementor/subclass and a
 * polymorphic method {@code T visit(element)} that dispatches to the right visitation method for the element that
 * is passed in.
 *
 * The interface that is generated should be implemented by all visitors visiting the class hierarchy.
 *
 * Motivation: The visitor design pattern can be immensely useful if used wisely. In essence, the visitor
 * design pattern allows for multiple dispatch over two (and if needed) more subjects by chaining single dynamic
 * dispatch on selfish methods. Furthermore, it allows the user to write code that is specific to subclasses of a
 * hierarchy inside the visitor rather than scattering that same code over many subclasses/implementors in the form
 * of overrides.
 *
 * Using the visitor design pattern in Java may cause some boilerplate which in turn may turn out to be error-prone
 * and not maintainable:
 *
 * <ul>
 *     <li>
 *         A code maintenance problem usually arises over time when the visitor pattern is employed as
 *         class hierarchies are modified, new implementors are added, so it would be useful to get a compiler error
 *         if a visitor has not implemented a visitation method (yet).
 *     </li>
 *     <li>
 *         The accept method of the visitor has to be written in the form of overrides inside the original class hierarchy.
 *         Again, it's tedious to do that (and maintain it) for the visitor/class pair.
 *     </li>
 * </ul>
 *
 * This annotation can be used on any class or interface. When found annotating a type {@code SomeRootClass},
 * an interface called {@code SomeRootClassVisitor<T>} is generated which defines a method
 *
 * <pre>
 * {@code
 *    T visitSpecificClass(SpecificClass element);
 * }
 * </pre>
 *
 * for each subclass/implementor and returns some generic type {@code T}. This generated interface needs to be
 * implemented by the user. If the hierarchy of classes is changed in some way, the visitor interface (which would be
 * regenerated by the build process) potentially causes compilation errors if implementations of the visitor interface
 * have not (yet) been adapted to that change.
 *
 * In addition to the specific visitation methods there is a method
 *
 * <pre>
 * {@code
 *    T visit(SomeRootClass element);
 * }
 * </pre>
 *
 * which when called on an {@code element} dispatches to the right override based on the dynamic type of {@code element}.
 * That eliminates the need for writing accept methods.
 */
@API(API.Status.INTERNAL)
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
public @interface GenerateVisitor {
    /**
     * .
     * @return suffix of the generated visitor interface
     */
    String classSuffix() default "Visitor";

    /**
     * .
     * @return prefix of all visitation methods
     */
    String methodPrefix() default "visit";

    /**
     * .
     * @return prefix we should attempt to remove from every discovered subclass when creating the name for the
     *         specific visitation method
     */
    String stripPrefix() default "";
}
