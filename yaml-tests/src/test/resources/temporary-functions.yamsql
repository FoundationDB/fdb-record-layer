#
# temporary-functions.yamsql
#
# This source file is part of the FoundationDB open source project
#
# Copyright 2021-2026 Apple Inc. and the FoundationDB project authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

---
schema_template:
    create table table_t1(id bigint, a bigint, b string, c integer, primary key(id))
    create table table_t2(id bigint, col1 bigint, col2 string, primary key(id))
    create table table_hierarchy(id bigint, parent_id bigint, name string, primary key(id))
---
# Define reusable transaction setups for temporary functions
transaction_setups:
  # Basic temporary table-valued function
  tvf_sq1: create temporary function sq1(in x bigint) on commit drop function AS
    SELECT * FROM table_t1 WHERE a < 40 + x

  # Another table-valued function with similar logic
  tvf_tmpFunction1: create temporary function tmpFunction1(in x bigint) on commit drop function AS
    SELECT * FROM table_t1 WHERE a < 40 + x

  # Function with multiple conditions
  tvf_tmpFunction2: create temporary function tmpFunction2(in x bigint) on commit drop function AS
    SELECT * FROM table_t1 WHERE a < 40 + x AND c > 150

  # Functions for join tests - T1 returns subset of table_t1
  tvf_T1: create temporary function T1() on commit drop function AS
    SELECT id, a, b, c FROM table_t1 WHERE a <= 30

  # Functions for join tests - T2 returns subset of table_t2
  tvf_T2: create temporary function T2() on commit drop function AS
    SELECT id, col1, col2 FROM table_t2 WHERE col1 >= 100

  # Function for self-join hierarchical tests
  tvf_Nodes: create temporary function Nodes() on commit drop function AS
    SELECT id, parent_id, name FROM table_hierarchy
---
setup:
  connect: 1
  steps:
    - query: INSERT INTO table_T1 VALUES (1, 10, 'test1', 100), (2, 20, 'test2', 200), (3, 30, 'test3', 300), (4, 50, 'test4', 400)
    - query: INSERT INTO table_T2 VALUES (1, 100, 'data1'), (2, 200, 'data2'), (3, 300, 'data3')
    - query: INSERT INTO table_hierarchy VALUES
        (1, null, 'root'),
        (2, 1, 'child1'),
        (3, 1, 'child2'),
        (4, 2, 'grandchild1'),
        (5, 2, 'grandchild2'),
        (6, 3, 'grandchild3')
---
test_block:
  name: temporary-table-valued-functions
  tests:
    -
      # Test basic temporary table-valued function
      - query: SELECT * FROM sq1(10)
      - setupReference: tvf_sq1
      - unorderedResult: [{ID: 1, A: 10, B: 'test1', C: 100}, {ID: 2, A: 20, B: 'test2', C: 200}, {ID: 3, A: 30, B: 'test3', C: 300}]
    -
      # Call tmpFunction1 with different parameter
      - query: SELECT * FROM tmpFunction1(20)
      - setupReference: tvf_tmpFunction1
      - unorderedResult: [{ID: 1, A: 10, B: 'test1', C: 100}, {ID: 2, A: 20, B: 'test2', C: 200}, {ID: 3, A: 30, B: 'test3', C: 300}, {ID: 4, A: 50, B: 'test4', C: 400}]
    -
      # Verify the function with multiple conditions filters correctly
      - query: SELECT * FROM tmpFunction2(10)
      - setupReference: tvf_tmpFunction2
      - unorderedResult: [{ID: 2, A: 20, B: 'test2', C: 200}, {ID: 3, A: 30, B: 'test3', C: 300}]
    -
      # Test joining two temporary functions with WHERE condition
      # T1() returns rows from table_t1 where a <= 30
      # T2() returns rows from table_t2 where col1 >= 100
      # Join on X.c = Y.col1 (table_t1.c matches table_t2.col1)
      - query: SELECT X.id AS x_id, X.a, X.b, X.c, Y.id AS y_id, Y.col1, Y.col2 FROM T1 AS X, T2 AS Y WHERE X.c = Y.col1
      - supported_version: !current_version
      - setupReference: tvf_T1
      - setupReference: tvf_T2
      - unorderedResult: [
          {X_ID: 1, A: 10, B: 'test1', C: 100, Y_ID: 1, COL1: 100, COL2: 'data1'},
          {X_ID: 2, A: 20, B: 'test2', C: 200, Y_ID: 2, COL1: 200, COL2: 'data2'},
          {X_ID: 3, A: 30, B: 'test3', C: 300, Y_ID: 3, COL1: 300, COL2: 'data3'}]
    -
      # Test the same join selecting fewer columns
      - query: SELECT X.a, Y.col2 FROM T1 AS X, T2 AS Y WHERE X.c = Y.col1
      - supported_version: !current_version
      - setupReference: tvf_T1
      - setupReference: tvf_T2
      - unorderedResult: [
          {A: 10, COL2: 'data1'},
          {A: 20, COL2: 'data2'},
          {A: 30, COL2: 'data3'}]
    -
      # Join with additional WHERE conditions
      - query: SELECT X.id, X.a, Y.col1 FROM T1 AS X, T2 AS Y WHERE X.c = Y.col1 AND X.a >= 20
      - supported_version: !current_version
      - setupReference: tvf_T1
      - setupReference: tvf_T2
      - unorderedResult: [
          {ID: 2, A: 20, COL1: 200},
          {ID: 3, A: 30, COL1: 300}]
    -
      # Self-join: find all parent-child relationships
      # Join Nodes() with itself where parent.id = child.parent_id
      - query: SELECT parent.id AS parent_id, parent.name AS parent_name, child.id AS child_id, child.name AS child_name FROM Nodes AS parent, Nodes AS child WHERE parent.id = child.parent_id
      - supported_version: !current_version
      - setupReference: tvf_Nodes
      - unorderedResult: [
          {PARENT_ID: 1, PARENT_NAME: 'root', CHILD_ID: 2, CHILD_NAME: 'child1'},
          {PARENT_ID: 1, PARENT_NAME: 'root', CHILD_ID: 3, CHILD_NAME: 'child2'},
          {PARENT_ID: 2, PARENT_NAME: 'child1', CHILD_ID: 4, CHILD_NAME: 'grandchild1'},
          {PARENT_ID: 2, PARENT_NAME: 'child1', CHILD_ID: 5, CHILD_NAME: 'grandchild2'},
          {PARENT_ID: 3, PARENT_NAME: 'child2', CHILD_ID: 6, CHILD_NAME: 'grandchild3'}]
    -
      # Self-join: find only direct children of root (id=1)
      - query: SELECT parent.name AS parent_name, child.name AS child_name FROM Nodes AS parent, Nodes AS child WHERE parent.id = child.parent_id AND parent.id = 1
      - supported_version: !current_version
      - setupReference: tvf_Nodes
      - unorderedResult: [
          {PARENT_NAME: 'root', CHILD_NAME: 'child1'},
          {PARENT_NAME: 'root', CHILD_NAME: 'child2'}]
    -
      # Self-join: find grandparent-grandchild relationships (skip a generation)
      # grandparent.id = parent.parent_id AND parent.id = grandchild.parent_id
      - query: SELECT grandparent.name AS grandparent, grandchild.name AS grandchild FROM Nodes AS grandparent, Nodes AS parent, Nodes AS grandchild WHERE grandparent.id = parent.parent_id AND parent.id = grandchild.parent_id
      - supported_version: !current_version
      - setupReference: tvf_Nodes
      - unorderedResult: [
          {GRANDPARENT: 'root', GRANDCHILD: 'grandchild1'},
          {GRANDPARENT: 'root', GRANDCHILD: 'grandchild2'},
          {GRANDPARENT: 'root', GRANDCHILD: 'grandchild3'}]
...
