#
# showcasing-tests.yamsql
#
# This source file is part of the FoundationDB open source project
#
# Copyright 2021-2024 Apple Inc. and the FoundationDB project authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# you can add comments like this one to your scripts.
# the file is split into "documents", each document can either be a config block or a test block.
#   - config block: This can be either a `setup` block or a `destruct` block. The motive of these block is to
#      "setup" and "clean" the environment needed to run the test blocks. Hence, the first block of the file should
#       be the `setup` block, while the last one should be `destruct`. A file can have multiple `setup` blocks
#       to change the environment as needed to run multiple test blocks. Config block consist of a list of commands.
#   - test block: Defines a scope for a group of tests by setting the knobs that determines how those tests are run.
---
setup:
  # First entry in a block should be `connect` that defines where to execute the block.
  connect: "jdbc:embed:/__SYS?schema=CATALOG"
  # the config block defines the list of steps that sets up the environment. Each step is a command of the form
  # <cmd>: <value> (pay attention to spaces). Valid commands are `load schema template`, `set schema state` and `query`.
  # In the following, we use the `query` command to run the DDL statements to set up our testing environment. Note that
  # the commands in config block are not tested for results - they are expected to succeed as they are for `setting up`
  # the testing environment and not the actual test.
  steps:
    - query: drop schema template if exists test_template
    # Here we use SQL to create the schema template.
    - query: create schema template test_template
       create table t1(id bigint, col1 bigint, primary key(id))
       create table t2(col1 bigint, primary key(col1))
       create table t3(col1 bigint, col2 string, primary key(col1))
    # Alternatively, you can directly load the schema template from a pre-crafted proto buf
    # file that you put in main/resources. For example:
    # load: schema template STANDARD_TESTS_TEMPLATE from com.apple.foundationdb.relational.yamltests.generated.standardtest.StandardTestsProto
    # check standard-tests-proto.yaml and standard_tests.proto for more information.
    - query: drop database if exists /FRL/YOUSSEF
    - query: create database /FRL/YOUSSEF
    - query: create schema /FRL/YOUSSEF/test with template test_template
---
setup:
  # Another setup block to fill the data in database created above.
  connect: "jdbc:embed:/FRL/YOUSSEF?schema=TEST"
  # We are inserting an array of three rows, each containing two columns
  # note the `table` configuration is very important
  # also note the casing of your table names.
  steps:
    - query: INSERT INTO T1 VALUES (10, 20), (30, 40), (50, 60)
---
test_block:
  # This defines the test block which contains actual test.
  # First entry in a block should be `connect`. That's true for even test_blocks
  # required.
  connect: "jdbc:embed:/FRL/YOUSSEF?schema=TEST"
  # preset defines one of the preset configurations that determines how the tests are run. There are 6 presets available
  # to choose from:
  #   1. single_repetition_ordered: Each test is run exactly once, in the order they are written. Cache is not checked.
  #   2. single_repetition_randomized: Each test is run exactly once, the order is randomized. Cache is not checked.
  #   3. single_repetition_parallelized: Each test is run exactly once, the order of test is randomized and execution is in parallel. Cache is not checked.
  #   4. multi_repetition_ordered: Each test is run more than once, in the order they are written. Cache is checked too.
  #   5. multi_repetition_randomized: Each test is run more than once, the order is randomized. Cache is checked too.
  #   6. multi_repetition_parallelized: Each test is run more than once, the order of test is randomized and execution is in parallel. Cache is checked too.
  # optional. default: multi_repetition_parallelized
  preset: single_repetition_ordered
  tests:
    -
      # We check here an error code, as you can see, the statement is syntactically
      # incorrect, this should throw SYNTAX_ERROR error whose SQL state is 42601
      # the `query` command has a configuration `error` implemented to check that.
      - query: selec * from t1;
      - error: "42601"
    -
      # in addition, the `query` command has a `result` configuration for checking
      # the result set, again using the same YAML format mentioned above.
      # we leverage YAML tags to implement more features such as partial matching
      # in partial matching, we can mark any part of a (nested) message with the
      # tag !ignore to inform the result set verifier that we do not really care about
      # the that value of the result set, this allows us to quickly test scenarios
      # in which we're e.g. interested in checking the values of the _first_ column
      # only, or we're interested in a particular deeply nested field in a message
      # without the rest of the message.
      # note: SnakeYAML parses numbers as Java Integers, however since we're expecting
      # Long in the result set, we implement a special YAML Tag (!l), which parses each
      # number as Long instead of Integer so we can do proper matching.
      - query: select * from t1 where id > 15;
      - result: [{!l 30, !ignore dc}, {!l 50, !ignore dc}]
    -
      # Having multiple `result` configs for the `query` command checks the result sets
      # (in order of appearance) with consecutive continuations of the query.
      - query: select * from t1 limit 1;
      - result: [{10, 20}]
      - result: [{30, 40}]
      - result: [{50, 60}]
---
# Another setup document to "change" the testing environment
setup:
  connect: "jdbc:embed:/__SYS?schema=CATALOG"
  steps:
    - query: drop schema template if exists test_template_nested
    # Here is a more complex schema template with nesting to show how to deal with nested
    # data.
    - query: create schema template test_template_nested
             CREATE TYPE AS STRUCT s1(col1 bigint, col2 string)
             CREATE TYPE AS STRUCT s2(col3 s1, col4 string)
             create table t1(id bigint, col5 s2, primary key(id))
             create table t2(id2 bigint, col6 s2 ARRAY, primary key(id2))
    - query: create schema /FRL/YOUSSEF/test_nested with template test_template_nested
---
setup:
  connect: "jdbc:embed:/FRL/YOUSSEF?schema=TEST_NESTED"
  steps:
    - query: insert into t1 values (100, (( 200, 'L3_1' ), 'L2_1')), (101, ((300, 'L3_2'), 'L2_2'))
---
# Another test block to test in the new "changed" environment
test_block:
  connect: "jdbc:embed:/FRL/YOUSSEF?schema=TEST_NESTED"
  # Running with defaults or declaring a preset is the preferred way of running the tests. However, the individual knobs
  # can be overridden in options, if the need be.
  options:
    # defines the execution mode in which the tests are run: ordered, randomized or parallelized.
    # optional. default: parallelized
    mode: ordered
    # defines how many times a particular tests should be scheduled.
    # optional. default: 5
    repetition: 1
    # defines the seed for the randomizer, if the mode is not `ordered`.
    # optional. default is `System.currentTimeMillis()`
    seed: 343434
    # specifies if a test should be executed again to make sure that its plan is retrieved from the cache.
    # optional. default: true
    check_cache: false
    # specifies the lifecycle of the created connection. For `test` the connection is created for each test execution.
    # For `block` the connection is created just once and all the tests are executed in that connection.
    # optional. default: test
    connection_lifecycle: block
  tests:
    -
      # We can selectively ignore part of the result set, by using the `!ignore dc` tag, which will cause
      # the matcher to always return true for that particular part of the message. This allows for
      # the matcher to always return true for that particular part of the message. This allows for
      # partial message matching which can make life easier in certain scenarios, e.g. verify that
      # the third struct field of the second column is ordered, without caring about the result of
      # the results.
      - query: select * from t1
      - result: [{!l 100, { {!l 200, 'L3_1'}, 'L2_1' } },  { !ignore _, { {!l 300, 'L3_2'}, 'L2_2' } }]
---
# Final document, clean-up the environment.
destruct:
  connect: "jdbc:embed:/__SYS?schema=CATALOG"
  steps:
    - query: drop schema template test_template
    - query: drop database /FRL/YOUSSEF
...
