#
# showcasing-tests.yaml
#
# This source file is part of the FoundationDB open source project
#
# Copyright 2021-2024 Apple Inc. and the FoundationDB project authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# you can add comments like this one to your scripts.
# the file is split into "regions", each region includes:
# a command of the form <cmd>: <value> (pay attention to spaces)
# an optional subsequent list of command configurations
# a value can span across multi lines, again please pay attention to
# proper spacing.
# In the following we'll start a new region to 'connect' to a database
# most commands are similar to Relational CLI's, in fact, we're
# using the CLI internal API to run them. such as the 'connect' command
# below.
---
- connect: "jdbc:embed:/__SYS?schema=CATALOG"
---
- query: drop schema template test_template
---
- query: create schema template test_template
   create table t1(id int64, col1 int64, primary key(id))
   create table t2(col1 int64, primary key(col1))
   create table t3(col1 int64, col2 string, primary key(col1))
---
- query: drop database /YOUSSEF
---
- query: create database /YOUSSEF
---
- query: create schema /YOUSSEF/test with template test_template
---
- connect: "jdbc:embed:/YOUSSEF?schema=TEST"
---
# We are inserting an array of three rows, each containing two columns
# note the `table` configuration is very important
# also note the casing of your table names.
- query: INSERT INTO T1 VALUES (10, 20), (30, 40), (50, 60)
---
# We check here an error code, as you can see, the statement is syntactically
# incorrect, this should throw SYNTAX_ERROR error whose SQL state is 42601
# the `query` command has a configuration `error` implemented to check that.
- query: selec * from t1;
- error: "42601"
---
# in addition, the `query` command has a `result` configuration for checking
# the result set, again using the same YAML format mentioned above.
# we leverage YAML tags to implement more features such as partial matching
# in partial matching, we can mark any part of a (nested) message with the
# tag !ignore to inform the result set verifier that we do not really care about
# the that value of the result set, this allows us to quickly test scenarios
# in which we're e.g. interested in checking the values of the _first_ column
# only, or we're interested in a particular deeply nested field in a message
# without the rest of the message.
# note: SnakeYAML parses numbers as Java Integers, however since we're expecting
# Long in the result set, we implement a special YAML Tag (!l), which parses each
# number as Long instead of Integer so we can do proper matching.
- query: select * from t1 where id > 15;
- result: [{!l 30, !ignore dc}, {!l 50, !ignore dc}]
---
# Having multiple `result` configs for the `query` command checks the result sets
# (in order of appearance) with consecutive continuations of the query.
- query: select * from t1 limit 1;
- result: [{10, 20}]
- result: [{30, 40}]
- result: [{50, 60}]
---
# Here is a more complex schema template with nesting to show how to deal with nested
# data.
- query: create schema template test_template_nested
         CREATE TYPE AS STRUCT s1(col1 int64, col2 string)
         CREATE TYPE AS STRUCT s2(col3 s1, col4 string)
         create table t1(id int64, col5 s2, primary key(id))
         create table t2(id2 int64, col6 s2 ARRAY, primary key(id2))
---
- query: create schema /YOUSSEF/test_nested with template test_template_nested
---
- connect: "jdbc:embed:/YOUSSEF?schema=TEST_NESTED"
---
# As you can see, it is much quicker to craft two relatively complex records using YAML
# syntax than JSON (which we use in CLI) and Java API (which we use in JUnit ITs).
# NOTE: YAML has its own nuance, when using it to define messages, make sure that keys are
# unique, i.e. it is not possible to define a message like this: {1,2,1} since YAML standard
# prohibits duplicate keys, to work around this issue, you can qualify the duplicate keys
# using their ProtoBuf message field (similar to JSON), e.g. {id: 1, 2, 1}.
- insert: [{!l 100, { {!l 200, 'L3_1'}, 'L2_1' } },  { !l 101, { {!l 300, 'L3_2'}, 'L2_2' } }]
- table: T1
---
# We can selectively ignore part of the result set, by using the `!ignore dc` tag, which will cause
# the matcher to always return true for that particular part of the message. This allows for
# partial message matching which can make life easier in certain scenarios, e.g. verify that
# the third struct field of the second column is ordered, without caring about the result of
# the results.
- query: select * from t1;
- result: [{!l 100, { {!l 200, 'L3_1'}, 'L2_1' } },  { !ignore _, { {!l 300, 'L3_2'}, 'L2_2' } }]
---
- connect: "jdbc:embed:/__SYS?schema=CATALOG"
---
- query: drop schema template test_template
---
- query: drop database /YOUSSEF
...
