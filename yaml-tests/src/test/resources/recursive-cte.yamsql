---
schema_template:
    create table t1(id bigint, parent bigint, primary key(id))
    create index parentIdx as select parent, id from t1 order by parent, id
    create index childIdx as select id, parent from t1 where parent is not null order by  id, parent
---
setup:
  steps:
#   1 (root, parent: -1)
#   ├── 10
#   │   ├── 40
#   │   ├── 50
#   │   │   └── 250
#   │   └── 70
#   └── 20
#       ├── 100
#       └── 210
    - query: insert into t1
            values (1, -1),
                   (10, 1),
                   (20, 1),
                   (40, 10),
                   (50, 10),
                   (70, 10),
                   (100, 20),
                   (210, 20),
                   (250, 50)
---
test_block:
  name: recursive-cte-tests-with-hints
  preset: multi_repetition_ordered
  tests:
    -
      - query: with recursive allDescendants as (
            select *  from t1 where id = 50
            union all
            select c.* from allDescendants as p, t1 as c use index (childIdx) where c.parent is not null and c.parent = p.id)
            traversal order pre_order
            select * from allDescendants
# WITH RECURSIVE allDescendants AS (SELECT * FROM ZoneState WHERE zoneKey = ? UNION ALL SELECT child.* FROM allDescendants AS parent, ZoneState AS child use index (zoneStateByParentRef) WHERE child.parentRef.zoneKey is not null AND child.parentRef.zoneKey = parent.zoneKey ) TRAVERSAL ORDER PRE_ORDER SELECT * FROM allDescendants
      - supported_version: !current_version
      - explain: "RUNION-DFS PREORDER q0 { ISCAN(CHILDIDX [EQUALS promote(@c13 AS LONG)]) } { RECURSIVE COVERING(CHILDIDX <,> -> [ID: KEY:[0], PARENT: KEY:[1]]) | FILTER _.PARENT EQUALS q0.ID AND _.PARENT NOT_NULL | MAP (_.ID AS ID, _.PARENT AS PARENT) }"
      - result: [{50, 10},
                 {250, 50}]
...
