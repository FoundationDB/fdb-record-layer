---
schema_template:
    create table t1(id bigint, parent bigint, primary key(id))
    create index parentIdx as select parent, id from t1 order by parent, id
    create index childIdx as select id, parent from t1 order by id, parent
---
setup:
  steps:
#   1 (root, parent: -1)
#   ├── 10
#   │   ├── 40
#   │   ├── 50
#   │   │   └── 250
#   │   └── 70
#   └── 20
#       ├── 100
#       └── 210
    - query: insert into t1
            values (1, -1),
                   (10, 1),
                   (20, 1),
                   (40, 10),
                   (50, 10),
                   (70, 10),
                   (100, 20),
                   (210, 20),
                   (250, 50)
---
test_block:
  name: recursive-cte-tests
  preset: single_repetition_ordered
  tests:
    -
      - query: with recursive c1 as (
            select id, parent, 0 as level from t1 where id = 250
            union all
            select b.id, b.parent, a.y as level from t1 as b, (select id, parent, level + 1 as y from c1) as a  where a.parent = b.id)
            traversal order pre_order
            select id, parent, level from c1
      - supported_version: 4.7.1.0
      - explain: "RUNION-DFS q0 { COVERING(CHILDIDX [EQUALS promote(@c19 AS LONG)] -> [ID: KEY[0], PARENT: KEY[1]]) | MAP (_.ID AS ID, _.PARENT AS PARENT, @c11 AS LEVEL) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q0.PARENT EQUALS _.ID | MAP (_.ID AS ID, _.PARENT AS PARENT, q0.LEVEL + @c49 AS LEVEL) } | MAP (_.ID AS ID, _.PARENT AS PARENT, _.LEVEL AS LEVEL)"
      - result: [{ID: 250, PARENT: 50, LEVEL: 0},
                 {ID: 50, PARENT: 10, LEVEL: 1},
                 {ID: 10, PARENT: 1, LEVEL: 2},
                 {ID: 1, PARENT: -1, LEVEL: 3}]
    -
      - query: with recursive c1 as (
            select id, parent, 0 as level from t1 where id = 250
            union all
            select b.id, b.parent, a.y as level from (select id, parent, level + 1 as y from c1) as a, t1 as b where a.parent = b.id)
            traversal order level_order
            select id, parent, level from c1
      - supported_version: 4.7.1.0
      - explain: "RUNION q0, q1 { INITIAL { COVERING(CHILDIDX [EQUALS promote(@c19 AS LONG)] -> [ID: KEY[0], PARENT: KEY[1]]) | MAP (_.ID AS ID, _.PARENT AS PARENT, @c11 AS LEVEL) | INSERT INTO TEMP q1 } RECURSIVE  { ISCAN(CHILDIDX <,>) | FLATMAP q2 -> { TEMP SCAN base() | FILTER _.PARENT EQUALS q2.ID AS q3 RETURN (q2.ID AS ID, q2.PARENT AS PARENT, q3.LEVEL + @c45 AS LEVEL) } | INSERT INTO TEMP q1 }} | MAP (_.ID AS ID, _.PARENT AS PARENT, _.LEVEL AS LEVEL)"
      - result: [{ID: 250, PARENT: 50, LEVEL: 0},
                 {ID: 50, PARENT: 10, LEVEL: 1},
                 {ID: 10, PARENT: 1, LEVEL: 2},
                 {ID: 1, PARENT: -1, LEVEL: 3}]
    -
      - query: with recursive c1 as (
            select id, parent from t1 where parent = -1
            union all
            select b.id, b.parent from c1 as a, t1 as b where a.id = b.parent) select id from c1
      - supported_version: 4.7.1.0
      - explain: "RUNION-DFS q0 { ISCAN(PARENTIDX [EQUALS promote(@c15 AS LONG)]) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q0.ID EQUALS _.PARENT | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID)"
      - initialVersionAtLeast: 4.7.1.0
      - result: [{ID: 1},
                 {ID: 10},
                 {ID: 40},
                 {ID: 50},
                 {ID: 250},
                 {ID: 70},
                 {ID: 20},
                 {ID: 100},
                 {ID: 210}]
      - initialVersionLessThan: 4.7.1.0
      # employs level-based traversal
      - result: [{ID: 1},
                 {ID: 10},
                 {ID: 20},
                 {ID: 40},
                 {ID: 50},
                 {ID: 70},
                 {ID: 100},
                 {ID: 210},
                 {ID: 250}]
    -
      - query: with recursive c1 as (
            select id, parent from t1 where parent = -1
            union all
            select b.id, b.parent from c1 as a, t1 as b where a.id = b.parent)
            traversal order level_order
            select id from c1
      - supported_version: 4.7.1.0
      - explain: "RUNION q0, q1 { INITIAL { ISCAN(PARENTIDX [EQUALS promote(@c15 AS LONG)]) | INSERT INTO TEMP q1 } RECURSIVE  { ISCAN(CHILDIDX <,>) | FLATMAP q2 -> { TEMP SCAN base() | FILTER _.ID EQUALS q2.PARENT AS q3 RETURN (q2.ID AS ID, q2.PARENT AS PARENT) } | INSERT INTO TEMP q1 }} | MAP (_.ID AS ID)"
      - unorderedResult: [{ID: 1},
                          {ID: 10},
                          {ID: 20},
                          {ID: 40},
                          {ID: 50},
                          {ID: 70},
                          {ID: 100},
                          {ID: 210},
                          {ID: 250}]
    -
      - query: with recursive c1 as (
            select id, parent from t1 where id = 250
            union all
            select b.id, b.parent from c1 as a, t1 as b where a.parent = b.id) select id from c1
      - explain: "RUNION-DFS q0 { ISCAN(CHILDIDX [EQUALS promote(@c15 AS LONG)]) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q0.PARENT EQUALS _.ID | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID)"
      - result: [{ID: 250},
                 {ID: 50},
                 {ID: 10},
                 {ID: 1}]
    -
      - query: with recursive c1 as (
            select id, parent from t1 where id = 250
            union all
            select b.id, b.parent from c1 as a, t1 as b where a.parent = b.id)
            traversal order level_order
            select id from c1
      - supported_version: 4.7.1.0
      - explain: "RUNION q0, q1 { INITIAL { ISCAN(CHILDIDX [EQUALS promote(@c15 AS LONG)]) | INSERT INTO TEMP q1 } RECURSIVE  { ISCAN(CHILDIDX <,>) | FLATMAP q2 -> { TEMP SCAN base() | FILTER _.PARENT EQUALS q2.ID AS q3 RETURN (q2.ID AS ID, q2.PARENT AS PARENT) } | INSERT INTO TEMP q1 }} | MAP (_.ID AS ID)"
      - result: [{ID: 250},
                 {ID: 50},
                 {ID: 10},
                 {ID: 1}]
    -
      - query: with recursive c1 as (
            select id, parent from t1 where id = 250
            union all
            select b.id, b.parent from c1 as a, t1 as b where a.parent = b.id)
            traversal order pre_order
            select id from c1
      - supported_version: 4.7.1.0
      - explain: "RUNION-DFS q0 { ISCAN(CHILDIDX [EQUALS promote(@c15 AS LONG)]) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q0.PARENT EQUALS _.ID | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID)"
      - result: [{ID: 250},
                 {ID: 50},
                 {ID: 10},
                 {ID: 1}]
    -
      - query: with recursive allDescendants as (
            with recursive ancestorsOf250 as (
            select id, parent from t1 where id = 250
            union all
            select b.id, b.parent from ancestorsOf250 as a, t1 as b where a.parent = b.id) select id, parent from ancestorsOf250
            union all
            select b.id, b.parent from allDescendants as a, t1 as b where a.id = b.parent) select id, parent from allDescendants
      - explain: "RUNION-DFS q0 { RUNION-DFS q1 { ISCAN(CHILDIDX [EQUALS promote(@c20 AS LONG)]) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q1.PARENT EQUALS _.ID | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID, _.PARENT AS PARENT) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q0.ID EQUALS _.PARENT | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID, _.PARENT AS PARENT)"
      - initialVersionAtLeast: 4.7.1.0
      - result: [{250, 50},
                 {50, 10},
                 {250, 50},
                 {10, 1},
                 {40, 10},
                 {50, 10},
                 {250, 50},
                 {70, 10},
                 {1, -1},
                 {10, 1},
                 {40, 10},
                 {50, 10},
                 {250, 50},
                 {70, 10},
                 {20, 1},
                 {100, 20},
                 {210, 20}]
      - initialVersionLessThan: 4.7.1.0
      - result: [{250, 50},
                 {50, 10},
                 {10, 1},
                 {1, -1},
                 {10, 1},
                 {20, 1},
                 {40, 10},
                 {50, 10},
                 {70, 10},
                 {250, 50},
                 {40, 10},
                 {50, 10},
                 {70, 10},
                 {100, 20},
                 {210, 20},
                 {250, 50},
                 {250, 50}]
    -
      - query: with recursive c1 as (
            select id, parent from t1 where parent = -1
            union all
            select b.id, b.parent from c1 as a, t1 as b where a.id = b.parent) select id from c1
      - supported_version: 4.7.1.0
      - explain: "RUNION-DFS q0 { ISCAN(PARENTIDX [EQUALS promote(@c15 AS LONG)]) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q0.ID EQUALS _.PARENT | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID)"
      - maxRows: 1
      - result: [{ID: 1}]
      - result: [{ID: 10}]
      - result: [{ID: 40}]
      - result: [{ID: 50}]
      - result: [{ID: 250}]
      - result: [{ID: 70}]
      - result: [{ID: 20}]
      - result: [{ID: 100}]
      - result: [{ID: 210}]
      - result: []
    -
      - query: with recursive c1 as (
            select id, parent from t1 where parent = -1
            union all
            select b.id, b.parent from c1 as a, t1 as b where a.id = b.parent) select id from c1
      - explain: "RUNION-DFS q0 { ISCAN(PARENTIDX [EQUALS promote(@c15 AS LONG)]) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q0.ID EQUALS _.PARENT | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID)"
      - maxRows: 1
      # new hierarchical plans contain a newly introduced physical operator, so new plan continuations can not be resumed on older versions
      # which is ok because we do not care about backward-compatibility for that particular scenario.
      - initialVersionAtLeast: 4.7.1.0
      - initialVersionLessThan: 4.7.1.0
      # employs level-based traversal
      - result: [{ID: 1}]
      - result: [{ID: 10}]
      - result: [{ID: 20}]
      - result: [{ID: 40}]
      - result: [{ID: 50}]
      - result: [{ID: 70}]
      - result: [{ID: 100}]
      - result: [{ID: 210}]
      - result: [{ID: 250}]
      - result: []
    -
      - query: with recursive allDescendants as (
            with recursive ancestorsOf250 as (
            select id, parent from t1 where id = 250
            union all
            select b.id, b.parent from ancestorsOf250 as a, t1 as b where a.parent = b.id) select id, parent from ancestorsOf250
            union all
            select b.id, b.parent from allDescendants as a, t1 as b where a.id = b.parent) select id, parent from allDescendants
      - supported_version: 4.7.1.0
      - explain: "RUNION-DFS q0 { RUNION-DFS q1 { ISCAN(CHILDIDX [EQUALS promote(@c20 AS LONG)]) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q1.PARENT EQUALS _.ID | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID, _.PARENT AS PARENT) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q0.ID EQUALS _.PARENT | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID, _.PARENT AS PARENT)"
      - maxRows: 1
      - result: [{250, 50}]
      - result: [{50, 10}]
      - result: [{250, 50}]
      - result: [{10, 1}]
      - result: [{40, 10}]
      - result: [{50, 10}]
      - result: [{250, 50}]
      - result: [{70, 10}]
      - result: [{1, -1}]
      - result: [{10, 1}]
      - result: [{40, 10}]
      - result: [{50, 10}]
      - result: [{250, 50}]
      - result: [{70, 10}]
      - result: [{20, 1}]
      - result: [{100, 20}]
      - result: [{210, 20}]
      - result: []
    -
      - query: with recursive allDescendants as (
            with recursive ancestorsOf250 as (
            select id, parent from t1 where id = 250
            union all
            select b.id, b.parent from ancestorsOf250 as a, t1 as b where a.parent = b.id) select id, parent from ancestorsOf250
            union all
            select b.id, b.parent from allDescendants as a, t1 as b where a.id = b.parent) select id, parent from allDescendants
      - explain: "RUNION-DFS q0 { RUNION-DFS q1 { ISCAN(CHILDIDX [EQUALS promote(@c20 AS LONG)]) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q1.PARENT EQUALS _.ID | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID, _.PARENT AS PARENT) } { RECURSIVE COVERING(PARENTIDX <,> -> [ID: KEY[1], PARENT: KEY[0]]) | FILTER q0.ID EQUALS _.PARENT | MAP (_.ID AS ID, _.PARENT AS PARENT) } | MAP (_.ID AS ID, _.PARENT AS PARENT)"
      - maxRows: 1
      # new hierarchical plans contain a newly introduced physical operator, so new plan continuations can not be resumed on older versions
      # which is ok because we do not care about backward-compatibility for that particular scenario.
      - initialVersionAtLeast: 4.7.1.0
      - initialVersionLessThan: 4.7.1.0
      - result: [{250, 50}]
      - result: [{50, 10}]
      - result: [{10, 1}]
      - result: [{1, -1}]
      - result: [{10, 1}]
      - result: [{20, 1}]
      - result: [{40, 10}]
      - result: [{50, 10}]
      - result: [{70, 10}]
      - result: [{250, 50}]
      - result: [{40, 10}]
      - result: [{50, 10}]
      - result: [{70, 10}]
      - result: [{100, 20}]
      - result: [{210, 20}]
      - result: [{250, 50}]
      - result: [{250, 50}]
      - result: []
#    -
# does not currently work due to bug in NLJ planning, see https://github.com/FoundationDB/fdb-record-layer/issues/2997
#      - query: with recursive c1 as (
#            select id, parent from t1 where id = 250
#            union all
#            select b.id, b.parent from c1 as a, t1 as b where a.parent = b.id and b.id > 40) select id from c1
#      - result: [{ID: 250},
#                 {ID: 50}]
...
