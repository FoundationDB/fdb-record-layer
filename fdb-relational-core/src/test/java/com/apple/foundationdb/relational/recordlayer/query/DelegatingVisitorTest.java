/*
 * DelegatingVisitorTest.java
 *
 * This source file is part of the FoundationDB open source project
 *
 * Copyright 2015-2025 Apple Inc. and the FoundationDB project authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.apple.foundationdb.relational.recordlayer.query;

import com.apple.foundationdb.record.PlanHashable;
import com.apple.foundationdb.record.query.plan.cascades.expressions.RecursiveUnionExpression;
import com.apple.foundationdb.record.query.plan.cascades.values.LiteralValue;
import com.apple.foundationdb.relational.api.ddl.NoOpQueryFactory;
import com.apple.foundationdb.relational.api.metadata.DataType;
import com.apple.foundationdb.relational.generated.RelationalLexer;
import com.apple.foundationdb.relational.generated.RelationalParser;
import com.apple.foundationdb.relational.recordlayer.ddl.NoOpMetadataOperationsFactory;
import com.apple.foundationdb.relational.recordlayer.metadata.RecordLayerColumn;
import com.apple.foundationdb.relational.recordlayer.metadata.RecordLayerIndex;
import com.apple.foundationdb.relational.recordlayer.metadata.RecordLayerSchemaTemplate;
import com.apple.foundationdb.relational.recordlayer.metadata.RecordLayerTable;
import com.apple.foundationdb.relational.recordlayer.query.visitors.BaseVisitor;
import com.apple.foundationdb.relational.recordlayer.query.visitors.DelegatingVisitor;
import com.apple.foundationdb.relational.recordlayer.query.visitors.TypedVisitor;
import org.antlr.v4.runtime.CommonTokenStream;
import org.apache.commons.lang3.mutable.MutableBoolean;
import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import org.mockito.Mockito;

import javax.annotation.Nonnull;
import java.net.URI;
import java.util.function.BiConsumer;
import java.util.function.Function;
import java.util.stream.Stream;

/**
 * This test ensures the `DelegatingVisitor` is invoked for internal SQL clauses that are not
 * top-level usable by end users, to address a test coverage gap identified by TeamScale.
 * <br>
 * The uncovered code stems from the query parsing mechanism: when parsing a non-trivial
 * SQL statement, the plan generation logic often bypasses the delegating visitor by
 * directly examining the parsing contexts and calling other methods. Consequently, TeamScale
 * flags some implementations in `DelegatingVisitor` as unused. However,
 * since the root interface `RelationalParserVisitor` is auto-generated by ANTLR, we must
 * implement these methods despite their limited practical usage.
 */
public class DelegatingVisitorTest {

    @Nonnull
    private static RecordLayerSchemaTemplate generateMetadata() {
        return RecordLayerSchemaTemplate
                .newBuilder()
                .addTable(
                        RecordLayerTable
                                .newBuilder(false)
                                .addColumn(
                                        RecordLayerColumn
                                                .newBuilder()
                                                .setName("R")
                                                .setDataType(DataType.Primitives.INTEGER.type())
                                                .build())
                                .setName("table1")
                                .build())
                .build();
    }

    /**
     * Generic test helper for visitor methods that return Object or void.
     *
     * @param query the SQL query to parse
     * @param parseMethod parser method to extract context
     * @param visitMethod delegating visitor method to test
     * @param visitorOverride function to create a BaseVisitor with overridden method
     */
    private <T> void testVisitor(String query,
                                 Function<RelationalParser, T> parseMethod,
                                 BiConsumer<DelegatingVisitor<BaseVisitor>, T> visitMethod,
                                 Function<MutableBoolean, BaseVisitor> visitorOverride) {
        final MutableBoolean called = new MutableBoolean(false);
        final var visitor = visitorOverride.apply(called);
        final var delegatingVisitor = new DelegatingVisitor<>(visitor);
        final var context = parseQuery(query, parseMethod);
        visitMethod.accept(delegatingVisitor, context);
        Assertions.assertThat(called.booleanValue()).as("Expecting the method to be called").isTrue();
    }

    /**
     * Simplified helper for most common case: parse, visit, assert called.
     */
    private <T> void testSimple(String query,
                                Function<RelationalParser, T> parseMethod,
                                BiConsumer<DelegatingVisitor<BaseVisitor>, T> visitMethod,
                                Function<MutableBoolean, BaseVisitor> visitorOverride) {
        testVisitor(query, parseMethod, visitMethod, visitorOverride);
    }

    private <T> T parseQuery(String query, Function<RelationalParser, T> parseMethod) {
        final var tokenSource = new RelationalLexer(new CaseInsensitiveCharStream(query));
        final var parser = new RelationalParser(new CommonTokenStream(tokenSource));
        return parseMethod.apply(parser);
    }

    private BaseVisitor createBaseVisitor(String query, MutableBoolean called) {
        return new BaseVisitor(
                new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, query, query, 42),
                generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE,
                URI.create("/FDB/FRL1"), null, false);
    }

    @Test
    void visitPredicatedExpressionTest() {
        testSimple("X BETWEEN 32 AND 43",
                RelationalParser::expression,
                (visitor, ctx) -> visitor.visitPredicatedExpression((RelationalParser.PredicatedExpressionContext) ctx),
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Nonnull
                    @Override
                    public Expression visitPredicatedExpression(@Nonnull RelationalParser.PredicatedExpressionContext ctx) {
                        called.setTrue();
                        return Expression.ofUnnamed(LiteralValue.ofScalar(42));
                    }
                });
    }

    @Test
    void visitSubscriptExpressionTest() {
        testSimple("X[42]",
                RelationalParser::expressionAtom,
                (visitor, ctx) -> visitor.visitSubscriptExpression((RelationalParser.SubscriptExpressionContext) ctx),
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Expression visitSubscriptExpression(@Nonnull RelationalParser.SubscriptExpressionContext ctx) {
                        called.setTrue();
                        return Expression.ofUnnamed(LiteralValue.ofScalar(42));
                    }
                });
    }

    @Test
    void visitUserDefinedScalarFunctionStatementBodyTest() {
        final var query = "AS testIdentifier";
        final MutableBoolean called = new MutableBoolean(false);
        final var visitor = new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, query, query, 42),
                generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
            @Nonnull
            @Override
            public Identifier visitUserDefinedScalarFunctionStatementBody(@Nonnull RelationalParser.UserDefinedScalarFunctionStatementBodyContext ctx) {
                called.setTrue();
                return Identifier.of("testIdentifier");
            }
        };
        final var delegatingVisitor = new DelegatingVisitor<>(visitor);
        final var routineBodyContext = parseQuery(query, RelationalParser::routineBody);
        Assertions.assertThat(routineBodyContext).isInstanceOf(RelationalParser.UserDefinedScalarFunctionStatementBodyContext.class);
        final var result = delegatingVisitor.visitUserDefinedScalarFunctionStatementBody(
                (RelationalParser.UserDefinedScalarFunctionStatementBodyContext) routineBodyContext);
        Assertions.assertThat(result).isEqualTo(Identifier.of("testIdentifier"));
        Assertions.assertThat(called.booleanValue()).isTrue();
    }

    @Test
    void visitUserDefinedScalarFunctionNameTest() {
        testSimple("fake query",
                RelationalParser::userDefinedScalarFunctionName,
                (visitor, ctx) -> Assertions.assertThat(visitor.visitUserDefinedScalarFunctionName(ctx)).isEqualTo("testFunction"),
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Nonnull
                    @Override
                    public String visitUserDefinedScalarFunctionName(@Nonnull RelationalParser.UserDefinedScalarFunctionNameContext ctx) {
                        called.setTrue();
                        return "testFunction";
                    }
                });
    }

    static Stream<String> traversalStrings() {
        return Stream.of("TRAVERSAL ORDER PRE_ORDER", "TRAVERSAL ORDER LEVEL_ORDER");
    }

    @ParameterizedTest
    @MethodSource("traversalStrings")
    void visitTraversalExpressionTest(String query) {
        testSimple(query,
                RelationalParser::traversalOrderClause,
                DelegatingVisitor::visitTraversalOrderClause,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, query, query, 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitTraversalOrderClause(RelationalParser.TraversalOrderClauseContext ctx) {
                        called.setTrue();
                        return query.equals("TRAVERSAL ORDER LEVEL_ORDER")
                                ? RecursiveUnionExpression.TraversalStrategy.LEVEL
                                : RecursiveUnionExpression.TraversalStrategy.PREORDER;
                    }
                });
    }

    @Test
    void visitViewDefinitionTest() {
        testSimple("VIEW V AS SELECT * FROM T",
                RelationalParser::viewDefinition,
                DelegatingVisitor::visitViewDefinition,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitViewDefinition(RelationalParser.ViewDefinitionContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitUserDefinedScalarFunctionCallTest() {
        testSimple("myFunction(123)",
                RelationalParser::functionCall,
                (visitor, ctx) -> visitor.visitUserDefinedScalarFunctionCall((RelationalParser.UserDefinedScalarFunctionCallContext) ctx),
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Nonnull
                    @Override
                    public Expression visitUserDefinedScalarFunctionCall(@Nonnull RelationalParser.UserDefinedScalarFunctionCallContext ctx) {
                        called.setTrue();
                        return Expression.ofUnnamed(LiteralValue.ofScalar(42));
                    }
                });
    }

    @Test
    void visitIndexOptionsTest() {
        testSimple("OPTIONS (LEGACY_EXTREMUM_EVER)",
                RelationalParser::indexOptions,
                DelegatingVisitor::visitIndexOptions,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitIndexOptions(@Nonnull RelationalParser.IndexOptionsContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitIndexOptionTest() {
        testSimple("LEGACY_EXTREMUM_EVER",
                RelationalParser::indexOption,
                DelegatingVisitor::visitIndexOption,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitIndexOption(@Nonnull RelationalParser.IndexOptionContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitVectorIndexDefinitionTest() {
        final var query = "VECTOR INDEX myIndex USING HNSW ON table1 (R)";
        testVisitor(query,
                RelationalParser::indexDefinition,
                (visitor, ctx) -> {
                    Assertions.assertThat(ctx).isInstanceOf(RelationalParser.VectorIndexDefinitionContext.class);
                    visitor.visitVectorIndexDefinition((RelationalParser.VectorIndexDefinitionContext) ctx);
                },
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, query, query, 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    @SuppressWarnings({"NullableProblems", "DataFlowIssue"})
                    public RecordLayerIndex visitVectorIndexDefinition(@Nonnull RelationalParser.VectorIndexDefinitionContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitPartitionClauseTest() {
        final var query = "PARTITION BY (col1)";
        testVisitor(query,
                RelationalParser::partitionClause,
                (visitor, ctx) -> {
                    Assertions.assertThat(ctx).isInstanceOf(RelationalParser.PartitionClauseContext.class);
                    visitor.visitPartitionClause(ctx);
                },
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, query, query, 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Nonnull
                    @Override
                    public Expressions visitPartitionClause(final RelationalParser.PartitionClauseContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitIndexColumnListTest() {
        testSimple("(col1, col2)",
                RelationalParser::indexColumnList,
                DelegatingVisitor::visitIndexColumnList,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    @SuppressWarnings({"NullableProblems", "DataFlowIssue"})
                    public Object visitIndexColumnList(@Nonnull RelationalParser.IndexColumnListContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitIncludeClauseTest() {
        testSimple("INCLUDE (col1, col2)",
                RelationalParser::includeClause,
                DelegatingVisitor::visitIncludeClause,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    @SuppressWarnings({"NullableProblems", "DataFlowIssue"})
                    public Object visitIncludeClause(@Nonnull RelationalParser.IncludeClauseContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitIndexOnSourceDefinitionTest() {
        final var query = "INDEX myIndex ON table1 (R)";
        testVisitor(query,
                RelationalParser::indexDefinition,
                (visitor, ctx) -> {
                    Assertions.assertThat(ctx).isInstanceOf(RelationalParser.IndexOnSourceDefinitionContext.class);
                    visitor.visitIndexOnSourceDefinition((RelationalParser.IndexOnSourceDefinitionContext) ctx);
                },
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, query, query, 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    @SuppressWarnings({"NullableProblems", "DataFlowIssue"})
                    public RecordLayerIndex visitIndexOnSourceDefinition(@Nonnull RelationalParser.IndexOnSourceDefinitionContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitIndexTypeTest() {
        testSimple("UNIQUE",
                RelationalParser::indexType,
                DelegatingVisitor::visitIndexType,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitIndexType(@Nonnull RelationalParser.IndexTypeContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitIndexColumnSpecTest() {
        testSimple("col1 ASC",
                RelationalParser::indexColumnSpec,
                DelegatingVisitor::visitIndexColumnSpec,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    @SuppressWarnings({"NullableProblems", "DataFlowIssue"})
                    public Object visitIndexColumnSpec(@Nonnull RelationalParser.IndexColumnSpecContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitIndexAsSelectDefinitionTest() {
        final var query = "INDEX myIndex AS SELECT * FROM table1";
        testVisitor(query,
                RelationalParser::indexDefinition,
                (visitor, ctx) -> {
                    Assertions.assertThat(ctx).isInstanceOf(RelationalParser.IndexAsSelectDefinitionContext.class);
                    visitor.visitIndexAsSelectDefinition((RelationalParser.IndexAsSelectDefinitionContext) ctx);
                },
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, query, query, 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    @SuppressWarnings({"NullableProblems", "DataFlowIssue"})
                    public RecordLayerIndex visitIndexAsSelectDefinition(@Nonnull RelationalParser.IndexAsSelectDefinitionContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitOrderClauseTest() {
        testSimple("ASC NULLS FIRST",
                RelationalParser::orderClause,
                DelegatingVisitor::visitOrderClause,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitOrderClause(@Nonnull RelationalParser.OrderClauseContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitVectorIndexOptionsTest() {
        testSimple("OPTIONS (EF_CONSTRUCTION = 100)",
                RelationalParser::vectorIndexOptions,
                DelegatingVisitor::visitVectorIndexOptions,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitVectorIndexOptions(@Nonnull RelationalParser.VectorIndexOptionsContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitHnswMetricTest() {
        testSimple("EUCLIDEAN_METRIC",
                RelationalParser::hnswMetric,
                DelegatingVisitor::visitHnswMetric,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitHnswMetric(@Nonnull RelationalParser.HnswMetricContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitVectorIndexOptionTest() {
        testSimple("EF_CONSTRUCTION = 100",
                RelationalParser::vectorIndexOption,
                DelegatingVisitor::visitVectorIndexOption,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitVectorIndexOption(@Nonnull RelationalParser.VectorIndexOptionContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitIndexPartitionClauseTest() {
        testSimple("PARTITION BY (col1)",
                RelationalParser::indexPartitionClause,
                DelegatingVisitor::visitIndexPartitionClause,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitIndexPartitionClause(@Nonnull RelationalParser.IndexPartitionClauseContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitWindowOptionsClauseTest() {
        testSimple("OPTIONS (ef_search = 100)",
                RelationalParser::windowOptionsClause,
                DelegatingVisitor::visitWindowOptionsClause,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Nonnull
                    @Override
                    public Expressions visitWindowOptionsClause(@Nonnull RelationalParser.WindowOptionsClauseContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitWindowOptionTest() {
        testSimple("ef_search = 100",
                RelationalParser::windowOption,
                DelegatingVisitor::visitWindowOption,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Nonnull
                    @Override
                    public Expression visitWindowOption(@Nonnull RelationalParser.WindowOptionContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitWindowSpecTest() {
        testSimple("(PARTITION BY col1 ORDER BY col2)",
                RelationalParser::windowSpec,
                DelegatingVisitor::visitWindowSpec,
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Override
                    public Object visitWindowSpec(@Nonnull RelationalParser.WindowSpecContext ctx) {
                        called.setTrue();
                        return null;
                    }
                });
    }

    @Test
    void visitNonAggregateFunctionCallTest() {
        testSimple("ROW_NUMBER() OVER (PARTITION BY col1 ORDER BY col2)",
                RelationalParser::functionCall,
                (visitor, ctx) -> visitor.visitNonAggregateFunctionCall((RelationalParser.NonAggregateFunctionCallContext) ctx),
                called -> new BaseVisitor(new MutablePlanGenerationContext(PreparedParams.empty(), PlanHashable.PlanHashMode.VC0, "", "", 42),
                        generateMetadata(), NoOpQueryFactory.INSTANCE, NoOpMetadataOperationsFactory.INSTANCE, URI.create("/FDB/FRL1"), null, false) {
                    @Nonnull
                    @Override
                    public Expression visitNonAggregateFunctionCall(@Nonnull RelationalParser.NonAggregateFunctionCallContext ctx) {
                        called.setTrue();
                        return Expression.ofUnnamed(LiteralValue.ofScalar(42));
                    }
                });
    }

    @Test
    void visitCopyImport() {
        final TypedVisitor baseVisitor = Mockito.mock(TypedVisitor.class);
        final DelegatingVisitor<TypedVisitor> delegating = new DelegatingVisitor<>(baseVisitor);
        final RelationalParser.CopyImportStatementContext context = new RelationalParser.CopyImportStatementContext(new RelationalParser.CopyStatementContext());
        final QueryPlan mockPlan = Mockito.mock(QueryPlan.class);
        Mockito.when(baseVisitor.visitCopyImportStatement(context)).thenReturn(mockPlan);
        final QueryPlan queryPlan = delegating.visitCopyImportStatement(context);
        Assertions.assertThat(queryPlan).isSameAs(mockPlan);
    }

    @Test
    void visitCopyExport() {
        final TypedVisitor baseVisitor = Mockito.mock(TypedVisitor.class);
        final DelegatingVisitor<TypedVisitor> delegating = new DelegatingVisitor<>(baseVisitor);
        final RelationalParser.CopyExportStatementContext context = new RelationalParser.CopyExportStatementContext(new RelationalParser.CopyStatementContext());
        final QueryPlan mockPlan = Mockito.mock(QueryPlan.class);
        Mockito.when(baseVisitor.visitCopyExportStatement(context)).thenReturn(mockPlan);
        final QueryPlan queryPlan = delegating.visitCopyExportStatement(context);
        Assertions.assertThat(queryPlan).isSameAs(mockPlan);
    }
}
